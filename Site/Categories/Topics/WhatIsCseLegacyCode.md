# What is CSE Legacy Code?

Successful computational engineering tools involve many person years of development. Nonetheless, software
development costs alone represent only a portion of stakeholder's (developers, users and consumers of results)
*total investment* in such tools. There are many ways in which stakeholders become *invested in* a computational
engineering tool. These include

* Software development costs
* User training and expertise in use of the tool
* Input model development costs
* Community adoption and development costs
* Perceived or measured committment to validity of results

Eventually, investments in a computational engineering tool, both tangible and intangible, become so great that
whole-sale re-write (that is throwing existing code out and re-writing from scratch), is not seen as an acceptable
strategy to move the code forward with new generation of computing hardware for which it was not originally designed.

The key software engineering challenge then becomes, keeping the existing source code largely intact running at
an acceptable level of performance, with computing technology for which it was not originally designed. This is the
crux and challange of *legacy code*.

In legacy code, changes to the code base are required to be *evolutionary* rather than *revolutionary*. Eventually,
however, even evolutionary code changes can become intractible. Typically, by the time legacy code faces this demise,
often more than 20 years of use, the evolutionary approach has provided ample time for suitable alternative tools to
develop.

A simple way to think about *legacy* code is that it is really, really old source code from a bygone era but which
has been carried forward, largely unchanged, through various generations of computing technology changes.

Contributed by: Mark C Miller
